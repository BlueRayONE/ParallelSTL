#pragma once

#include <type_traits>
#include <memory>

namespace std {
namespace experimental {
namespace parallel {

// parallel.execpol.synop
// **********************************************

// 2.3, execution policy type trait
template<class T> struct is_execution_policy;

// 2.4, sequential execution policy
class sequential_execution_policy;

// 2.5, parallel execution policy
class parallel_execution_policy;

// 2.6, vector execution policy
class vector_execution_policy;

// 2.7, dynamic execution policy
class execution_policy;

// 2.9, standard execution policy objects
//extern const sequential_execution_policy seq;
//extern const parallel_execution_policy par;
//extern const vector_execution_policy vec;

// parallel.execpol.type
// **********************************************

template<class T> struct is_execution_policy
  : public integral_constant<bool, is_base_of<sequential_execution_policy, 
                                              typename decay<T>::type>::value || 
                                   is_base_of<parallel_execution_policy, 
                                              typename decay<T>::type>::value || 
                                   is_base_of<vector_execution_policy, 
                                              typename decay<T>::type>::value ||
                                   is_base_of<execution_policy, 
                                              typename decay<T>::type>::value > { };


namespace detail {
template<class T, class U> struct __enable_if_parallel_alg_helper
  : public enable_if<is_base_of<sequential_execution_policy, typename decay<T>::type>::value ||
                     is_base_of<parallel_execution_policy, typename decay<T>::type>::value ||
                     is_base_of<execution_policy, typename decay<T>::type>::value,
                     U> { };

template<class T, class U> struct __enable_if_execution_policy_helper
  : public enable_if<is_base_of<execution_policy, typename decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_sequential_policy_helper
  : public enable_if<is_base_of<sequential_execution_policy, typename decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_parallel_policy_helper
  : public enable_if<is_base_of<parallel_execution_policy, typename decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_vector_policy_helper
  : public enable_if<is_base_of<vector_execution_policy, typename decay<T>::type>::value, U> { };

} // namespace detail

// parallel.execpol.dynamic
// **********************************************

#ifdef _WIN32
# define __NOEXCEPT
#else
# define __NOEXCEPT noexcept
#endif

class execution_policy{
  shared_ptr<void> _instance;
  const type_info *_type;
public:
  // 2.7.1, construct/assign
  template<class ExecutionPolicy>
  execution_policy(const ExecutionPolicy& policy,
                   typename enable_if<is_execution_policy<ExecutionPolicy>::value,
                                                          ExecutionPolicy>::type* = nullptr)
  {
    _instance = std::make_shared<ExecutionPolicy>(policy);
    _type = &typeid(ExecutionPolicy);
  }

  template<class ExecutionPolicy>
  typename std::enable_if<is_execution_policy<ExecutionPolicy>::value, execution_policy>::type&
  operator=(const ExecutionPolicy & policy) 
  {
    _instance = std::make_shared<ExecutionPolicy>(policy);
    _type = &typeid(policy);
    return *this;
  }

  // 2.7.2, object access
  const type_info& type() const __NOEXCEPT 
  {
    return *_type;
  }

  template<class ExecutionPolicy> ExecutionPolicy* get() __NOEXCEPT
  {
    if (*_type != typeid(ExecutionPolicy)) return nullptr; 
    return static_cast<ExecutionPolicy*>(_instance.get());
  }

  template<class ExecutionPolicy> const ExecutionPolicy* get() const __NOEXCEPT
  {
    if (*_type != typeid(ExecutionPolicy)) return nullptr;
    return static_cast<ExecutionPolicy*>(_instance.get()); 
  }

  template<class RandomAccessIterator>
    void sort(RandomAccessIterator first, RandomAccessIterator last) const;

};

#undef __NOEXCEPT

}
} // namespace experimental
} // namespace std

#include <experimental/bits/parallel/policy_sequential.h>
#include <experimental/bits/parallel/policy_parallel.h>
#include <experimental/bits/parallel/policy_dynamic.h>
