#pragma once

#include <type_traits>

namespace std {
namespace experimental {
namespace parallel {

// parallel.execpol.synop
// **********************************************

// 2.3, execution policy type trait
template<class T> struct is_execution_policy;

// 2.4, sequential execution policy
class sequential_execution_policy;

// 2.5, parallel execution policy
class parallel_execution_policy;

// 2.6, vector execution policy
class vector_execution_policy;

// 2.7, dynamic execution policy
class execution_policy;

// 2.9, standard execution policy objects
//extern const sequential_execution_policy seq;
//extern const parallel_execution_policy par;
//extern const vector_execution_policy vec;

// parallel.execpol.type
// **********************************************

template<class T> struct is_execution_policy
  : public integral_constant<bool, is_base_of<sequential_execution_policy, typename decay<T>::type>::value || 
                                   is_base_of<parallel_execution_policy, typename decay<T>::type>::value || 
                                   is_base_of<vector_execution_policy, typename decay<T>::type>::value ||
                                   is_base_of<execution_policy, typename decay<T>::type>::value > { };


namespace detail {
template<class T, class U> struct __enable_if_parallel_alg_helper
  : public enable_if<is_base_of<sequential_execution_policy, typename std::decay<T>::type>::value ||
                     is_base_of<parallel_execution_policy, typename std::decay<T>::type>::value ||
                     is_base_of<execution_policy, typename std::decay<T>::type>::value,
                     U> { };

template<class T, class U> struct __enable_if_execution_policy_helper
  : public enable_if<is_base_of<execution_policy, typename std::decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_sequential_policy_helper
  : public enable_if<is_base_of<sequential_execution_policy, typename std::decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_parallel_policy_helper
  : public enable_if<is_base_of<parallel_execution_policy, typename std::decay<T>::type>::value, U> { };

template<class T, class U> struct __enable_if_vector_policy_helper
  : public enable_if<is_base_of<vector_execution_policy, typename std::decay<T>::type>::value, U> { };

} // namespace detail

// parallel.execpol.dynamic
// **********************************************

#ifdef _WIN32
# define __NOEXCEPT
#else
# define __NOEXCEPT noexcept
#endif

class execution_policy{
public:
  // 2.7.1, construct/assign
  template<class T> execution_policy(const T& exec);
  template<class T> execution_policy& operator=(const T& exec);

  // 2.7.2, object access
  const type_info& type() const __NOEXCEPT;

  template<class T> T* get() __NOEXCEPT;

  template<class T> const T* get() const __NOEXCEPT;
};

#undef __NOEXCEPT

}
} // namespace experimental
} // namespace std

#include <experimental/bits/parallel/policy_sequential.h>
#include <experimental/bits/parallel/policy_parallel.h>

