#include <type_traits>

namespace std {
namespace experimental {
namespace parallel {

// parallel.execpol.synop
// **********************************************

// 2.3, execution policy type trait
template<class T> struct is_execution_policy;

// 2.4, sequential execution policy
class sequential_execution_policy;

// 2.5, parallel execution policy
class parallel_execution_policy;

// 2.6, vector execution policy
class vector_execution_policy;

// 2.7, dynamic execution policy
class execution_policy;

// 2.9, standard execution policy objects
//extern const sequential_execution_policy seq;
//extern const parallel_execution_policy par;
//extern const vector_execution_policy vec;

// parallel.execpol.type
// **********************************************

template<class T> struct is_execution_policy
  : public integral_constant<bool, is_same<typename decay<T>::type, sequential_execution_policy>::value || 
                                   is_same<typename decay<T>::type, parallel_execution_policy>::value || 
                                   is_same<typename decay<T>::type, vector_execution_policy>::value ||
                                   is_same<typename decay<T>::type, execution_policy>::value > { };

// parallel.execpol.dynamic
// **********************************************

class execution_policy{
public:
  // 2.7.1, construct/assign
  template<class T> execution_policy(const T& exec);
  template<class T> execution_policy& operator=(const T& exec);

  // 2.7.2, object access
  const type_info& type() const noexcept;
  template<class T> T* get() noexcept;
  template<class T> const T* get() const noexcept;
};

}
} // namespace experimental
} // namespace std

#include <experimental/bits/parallel/policy_sequential.h>
#include <experimental/bits/parallel/policy_parallel.h>

